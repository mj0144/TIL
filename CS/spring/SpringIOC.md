### 제어역전

자신이 사용할 오브젝트를 결정하고, 필요한 시점에서 생성하는 등의 모든 종류의 작업을 사용하는 쪽에서 제어함.

`제어의 역전`이란 이런 제어흐름을 뒤집는 것.

제어 역전에서는 **오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않음. 생성도 하지 않음. 또 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없음.**

모든 제어 권한을 다른 대상에게 위임하기 때문.

서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출함.

=> 이렇게 서블릿이나 JSP처럼 컨테이너 안에서 동작하는 구조는 간단하긴 하나 제어의 역전 개념이 적용되어 있다고 볼수 있음.

라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어함.

프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용됨.

보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만들 애플리케이션 코드를 사용하도록 만드는 방식.

프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야함. 애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야함.

### 스프링 IOC

**Bean의 생성과 관계설정 같은 제어를 담당하는 IOC 오브젝트**를 `BeanFactory`라 함.

보통 BeanFactory보다는 이를 확장한 ApplicationContext를 주로 사용함. ( 상속관계 )

ApplicationContext == BeanFactory 라고 생각하자.

BeanFactory는 빈을 생성하고 관계를 설정하는 Ioc 기본 기능에 초점을 맞춘 것이고,

ApplicationContext는 애플리케이션 전반에 걸쳐 모든 구성요소의 제어작업을 담당하는 Ioc 엔진이라는 의미가 좀 더 부각.

ApplicationContext는 별도의 정보(servlet-context.xml 등)를 참고해 제어 작업을 총괄.

**`ApplicationContext`**를 **`IOC컨테이너`**라 하기도 하고, **`Spring컨테이너`**라고도 함.

### 애플리케이션 컨텍스트 동작방식

애플리케이션 컨텍스트가 스프링의 가장 대표적인 오브젝트.

java 코드 이용

- `@Configuration`이 붙은 클래스를 애플리케이션 컨텍스트가 설정 정보로 사용.
- 안에 @Bean이 붙어 있는 메서드의 이름을 가져가 빈(Bean) 목록을 만듦.

애플리케이션 컨텍스트가 있으면 이를 사용할 때 일관된 방식으로 원하는 오브젝트를 가져올 수 있음.

오브젝트 생성 뿐 아니라, 오브젝트가 만들어지는 방식, 시점 전략을 다르게 가져갈 수도 있고,

이에 부가적으로 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정받식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공함.

또, 빈이 사용할 수 있는 기반기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공해주기도 함.

애플리케이션 컨텐스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어지는데, 이를 통틀어서 `스프링 컨테이너`라고 부름.

`IoC컨테이너` : 주로 빈 팩토리 관리하는 점에서 이야기하는 것

`컨테이너` or `Spring 컨테이너` : 애플리케이션 컨텍스트를 가리키는 것.

`스프링 프레임워크` : IoC컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때.

### 왜 스프링은 싱글톤으로 빈을 만드는가…?

스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문.

클라이언트에서 요청이 올 때마다 오브젝트를 새로 만들어서 내어줄 수 없기 때문.

`서블릿` : 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트.

서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작함.

서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용함.

### 싱글톤의 문제점

private 생성자를 갖고 있기 때문에 상속이 불가능. 즉, 다형성 적용 불가.

테스트하기가 힘듦

서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못함

- 서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있음.
- 여러 개의 JVM에 분산돼서 설치가 되는 경우에도 각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어짐.

스프링이 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공하는 것이 `싱글톤 레지스트리`

`스프링 컨테이너`는 **싱글톤을 생성,관리,공급하는 싱글톤 관리 컨테이너이기도함.**

싱글톤 레지스트리는 static 메서드와 private 생성자를 사용해야 하는 싱글톤을 평범한 자바 클래스를 싱글톤으로 활용하게 해줌.

스프링의 싱글톤 레지스트리 덕분에 싱글톤 방식으로 사용될 애플리케이션 클래스라도 public 생성자를 가질 수 있음.

### DI(Dependency Injection)

오브젝트는 다른 오브젝트에 주입하는게 아닌 오브젝트의 레퍼런스가 전달되는 것 뿐임.

**의존관계주입의 핵심은 설계 시전에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는 것.**

### DL(의존관계 검색)

**의존 관계를 맞는 방법이 외부로부터의 주입이 아닌 스스로 검색 하여 필요로 하는 의존 오브젝트를 능동적으로 찾음**

물론 자신이 어떤 클래스의 오브젝트를 사용할지 결정하지는 않음. 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 생성하는 작업은 외부컨테이너에게 IOC로 맡기지만 이를 가져올 때는 메서드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용함.

애플리케이션 컨텍스트는 getBean()이라는 메서드를 제공함.

이 메서드가 의존관계 검색에 사용되는 것.

대게 의존관계 주입을 사용하지만 의존관계 검색을 사용해야할 때가 있음.

서버에 main()과 비슷한 역할을 하는 서블릿에서 스프링 컨테이너에 담긴 오브젝트를 사용하려면 한번은 의존관계 검색방식을 사용해 오브젝트를 가져와야함. 

-> 근데 이런 서블릿은 스프링이 미리 만들어 제공하고 있음.

의존 관계 검색방식의 오브젝트는 자신이 스프링의 빈일 필요가 없음. 이게 DI와 가장 큰 차임.

**DI를 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 되어야함...!!**