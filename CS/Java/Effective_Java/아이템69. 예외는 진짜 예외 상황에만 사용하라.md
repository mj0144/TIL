```java
try {
	int i=0;
	while(true)
		trange[i++].climb();
} catch(ArrayIndexOutOfBoundsException e) {
}
```

### 위 코드의 문제점 - 예외로 루프 종료

1. JVM은 배열에 접근할 때마다 경계를 넘지 않는지 검사를 하는데, 일반적인 반복문 또한 경계에 도달하면 종료한다.
    
    → 따라서 위 코드는 같은 일이 중복되므로 하나를 생략한 것.
    
2. 코드를 try-catch 블럭 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한됨.
3. 제대로 동작하지 않을 수 있음.
    - 반복문에 버그가 숨어있는 경우 디버깅이 더 어렵다.
        - 엉뚱한 예외를 정상적인 반복문 종료 상황을 볼 수도 있다.

예외는 오직 예외 상황에서만 써야한다.

절대로 일상적인 제어 흐름용으로 쓰여선 안 된다.

잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.

→ 상태 의존적 메서드를 제공하는 클래스는 상태 검사 메서드도 함께 제공해야 함.

이러한 예로 Iterator인터페이스의 next(상태 의존적 메서드)와 hasNext(상태 검사 메서드)가 있다.

상태 검사 메서드가 있는 경우 아래와 같이 사용이 가능하나.

```java
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
	Foo foo = i.next();
	...
}
```

만일 상태 검사 메서드가 없는 경우 아래와 같이 사용될 수 있다

```java
try {
	Iterator<Foo> i = collection.iterator();
	while(true) {
		Foo foo = i.next();
		...
	}
} catch (NoSuchElementExeption e) {
}
```

추가로 `상태 검사 메서드` 대신 올바르지 않은 상태일 때 `Optional` 또는 `null`과 같은 특수한 갑승ㄹ 반환하는 방법도 있다.

`상태 검사 메서드`, `Optional`, `특정 값` 중 하나를 선택하는 지침은 아래와 같다.

1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 `Optional`이나 `특정값`을 사용한다. 
    
    → `상태 검사 메서드`와 `상태 의존적 메서드` 호출 사이에 객체의 상태가 변할 수 있기 때문.
    
2. 성능이 중요한 상황에서 `상태 검사 메서드`가 `상태 의존적 메서드`의 작업 일부를 중복 수행한다면 `Optional`이나 `특정 값`을 선택한다.
3. 다른 모든 경우엔 `상태 검사 메서드` 방식이 조금 더 낫다고 할 수 있다. 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 쉽다. `상태 검사 메서드` 호출을 깜빡 잊었다면 `상태 의존적 메서드`가 예외를 던져 버그가 확실하게 드러날 것이다.